import re
import time
import traceback
from urllib.parse import urljoin
from urllib.parse import urlparse
from urllib.parse import urlencode
from html.parser import HTMLParser
from lib.core.common import getRootDomain
from lib.core.common import RequestProcessor

class ResponseParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.urlMatch=True
        self.request_results=list()
        self.re_urls=re.compile(r'(?:(?:[0-9.a-zA-Z:/]*)[.\/][a-zA-Z0-9{}?._!=&\\]*)')
        self.usernameKeywords=[
                "user",
                "usr",
                "name",
                "id"
                ]
        self.passwordKeywords=[
                "pass",
                "pwd"
                ]
        self.verifyCodeKeywords=[
                "vertify",
                "verify",
                "captcha",
                "code",
                "ver"
                ] 
    
    def parse(self, response):
        try:
            super().reset()
            self.in_form=False
            self.in_title=False
            self.url=response["url"]
            self._urlparser_=urlparse(self.url)
            self.root_domain=getRootDomain(self.url)
            self._webroot_=self._urlparser_.scheme+"://"+self._urlparser_.netloc
            self.result={"Page":list(), "Title":str(), "status_code":response["status_code"], "text_length": len(response["text"]), "url":response["url"]}
 
            start_time = time.time()
            self.feed(response["text"] if response else str())

            for request in self.result["Page"]:
                data=dict()
                if not request: continue
                if not request.get("method"): request["method"]="GET"

                if request.get("method").upper()=="POST":
                    if not request.get("inputs"): continue
                    for _input in request.get("inputs"):
                        if _input.get("type")=="password" or any(keyword in _input.get("id",str()) for keyword in self.passwordKeywords) or any(keyword in _input.get("name",str()) for keyword in self.passwordKeywords):
                            data[_input.get("name")] = "{password}"

                        elif any(keyword in _input.get("id",str()) for keyword in self.verifyCodeKeywords) or any(keyword in _input.get("name",str()) for keyword in self.verifyCodeKeywords):
                            data[_input.get("name")] = "{code}"

                        elif any(keyword in _input.get("id",str()) for keyword in self.usernameKeywords) or any(keyword in _input.get("name",str()) for keyword in self.usernameKeywords):
                            data[_input.get("name")] = "{username}"

                        else:
                            data[_input.get("name")] = _input.get("value",str()) if _input.get("name",str()) not in data else data[_input.get("name")]

                elif request.get("method").upper()=="GET":
                    pass
                else: ...

                uri=urljoin(self._webroot_, request.get("action"))
                data=urlencode( data, doseq=True, safe="{}" )
                self.request_results.append( RequestProcessor(uri, data=data) )
                
        except Exception as e:
            print("[!] Parser Error : "+str(e))
            print(traceback.format_exc())

        self.result["Page"] = self.request_results
        return self.result

    def urls_match(self, text):
        if not self.urlMatch==True:return list()

        def basic_judgment(url):
            special_characters=":;'{}()[]<>"
            if url[0] in special_characters:
                return False
            if self.root_domain and self.root_domain in url:
                return True
            if "="*3 in url:
                return False

            for part in url.split("."):
                if len(part)>2 and (("/" in part) or ("\\" in part)) and not part == str(): 
                    pass
                else:return False

            for part in url.split("/"):
                if len(part) > 2:
                    pass
                else:return False
            return True

        return [ url for url in self.re_urls.findall(text,re.MULTILINE) if basic_judgment(url)]

    def handle_starttag(self, tag, attrs):
        if tag=="title": self.in_title=True

        form_data = dict()
        form_inputs = list()
        
        if tag == 'form':
            self.in_form = True
            for attr in attrs:
                if attr[0] == 'method':
                    form_data['method'] = attr[1]
                elif attr[0] == 'action':
                    form_data['action'] = attr[1]
        if form_data.get("method")=="POST":form_data["inputs"]=form_inputs

        if self.in_form and tag == 'input':
            _input = dict()

            for attr in attrs:
                key, value = str(attr[0]), str(attr[1])
                if key == 'name':
                    _input["name"] = value
                elif key == 'value':
                    _input["value"] = value
                elif key == 'type':
                    _input["type"] = value
                else:
                    _input[key] = value
                form_inputs.append(_input)

            form_data["inputs"] = form_inputs

        if form_data: self.result["Page"].append( form_data )

        for _attr, _value in attrs:
            if _attr=="href" and _value and any(char.isalpha() for char in _value) and not _value.startswith("javascript:"):
                self.result["Page"].append( { "method":"GET","action":_value,"inputs":list() } )
            elif _attr=="src" and _value and any(char.isalpha() for char in _value) and not _value.startswith("javascript:"):
                self.result["Page"].append( { "method":"GET","action":_value,"inputs":list() } )
            else:...

    def handle_endtag(self, tag):
        if tag == 'form':
            self.in_form = False
        elif tag == 'title':
            self.in_title = False
    
    def handle_data(self, data):
        if self.in_title: self.result["Title"]=data
        urls=self.urls_match(data) if self.urlMatch else list()
        requests=[{"method":"GET","action":self.url_join(url)} for url in urls]
        if urls: self.result["Page"].extend(requests)

    def handle_comment(self, data):
        urls=self.urls_match(data) if self.urlMatch else list()
        requests=[{"method":"GET","action":self.url_join(url)} for url in urls]
        if urls: self.result["Page"].extend(requests)

    def url_join(self,url):
        if url.startswith("http://") or url.startswith("https://"):
            return url
        if self.root_domain and self.root_domain in url:
            return self._urlparser_.scheme+"://"+url
        return urljoin(self._webroot_,url)


