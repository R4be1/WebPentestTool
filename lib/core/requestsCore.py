import re
import time
import socket
import aiohttp
import asyncio
import traceback
from urllib.parse import urljoin
from urllib.parse import urlparse
from lib.core.parsers import ResponseParser


async def requests_async_function_(
        tasks, 
        IP=True, 
        URL=True, 
        TEXT=True, 
        PRINT=True, 
        TITLE=False,
        HEADERS=True, 
        CONTENT=False, 
        STATUS_CODE=True, 
        TEXT_LENGTH=True, 
        semaphore=512,
        timeout=70
        ):

    media_type = ["image/","video/","audio/","application/zip","application/x-rar-compressed","application/x-tar","application/gzip","application/x-7z-compressed","application/pdf","application/msword","application/vnd.ms-excel","application/vnd.ms-powerpoint","application/font"]

    async with aiohttp.ClientSession( timeout=aiohttp.ClientTimeout( total=timeout ), connector=aiohttp.TCPConnector( ssl=False ) ) as session:

        _semaphore = asyncio.Semaphore(semaphore) if semaphore else asyncio.Semaphore()

        async def async_request(task):
            if not task: return dict()
            try:
                async with _semaphore:
                    start_time=time.time()

                    async with session.request(
                            url = urljoin( task.get( "webroot" ),task.get("path") ),
                            method = "GET" if not task.get( "data" ) else "POST",
                            headers={"User-Agent":"Mozilla/5.0 (Windows NT x.y; WOW64; rv:10.0) Gecko/20100101 Firefox/10.0"},
                            timeout = aiohttp.ClientTimeout( total=174 ),
                            params = task.get( "params" ),
                            data = task.get( "data" )
                            ) as response:

                        if response is not None:
                            if IP==True:
                                try:
                                    ip = socket.gethostbyname(response.host)
                                except Exception as e:
                                    print(f"{response.host} Socket Get Ip Error: {e}")
                                    ip = "000.000.000.000"
                                response.ip = ip
                            else:
                                response.ip = str()

                            if TEXT==False and TEXT_LENGTH==False and TITLE==False:
                                pass
                            else:
                                response.text = await response.text(errors="replace")

                            if TEXT_LENGTH==True:
                                response.text_length = len(response.text)

                            if TITLE==True:
                                title = re.search(r'<title[^>]*>(.*?)</title>', response.text, re.IGNORECASE)
                                response.title =  title.group(1) if title else str()

                            if PRINT:
                                print(f"[{response.status}]  {str(response.text_length).ljust(7)+'  ' if TEXT_LENGTH else ''}{response.ip.ljust(15)}  {response.url}")

                            TYPE=True
                            content_type = response.headers.get("Content-Type")

                            for _type in media_type:
                                if content_type and _type in content_type:
                                    TYPE=False
                                    response.text=str()

                            response.text = response.text if TEXT and TYPE else str()
                            response.content = await response.read() if CONTENT else str()

                        return {
                                "ip" : str(response.ip) if IP else str(),
                                "url" : str(response.url) if URL else str(),
                                "text" : str(response.text) if TEXT else str(), 
                                "title" : str(response.title) if TITLE else str(),
                                "content" : responses.content if CONTENT else bytes(),
                                "headers" : dict(response.headers) if HEADERS else dict(), 
                                "status_code" : int(response.status) if STATUS_CODE else int(),
                                "text_length" : int(response.text_length) if TEXT_LENGTH else int()
                                }

            except Exception as e:
                # print(f"\033[91m[!] {urljoin( task.get('webroot'), task.get('path')) }  Exception:{e}\033[0m")
                # print(f"[!] Exception:{traceback.format_exc()}")
                return dict()

        tasks = [ asyncio.create_task(async_request(task)) for task in tasks ]
        responses = await asyncio.gather(*tasks)
        
    return responses

def requests_responses(tasks, timeout=70, semaphore=2048, **kwargs) -> list():
    responses = asyncio.run(requests_async_function_(
        tasks = tasks,
        timeout = timeout,
        semaphore = semaphore,
        IP = kwargs.get("IP") if kwargs.get("IP") is not None else True,
        URL = kwargs.get("URL") if kwargs.get("URL") is not None else True,
        TEXT = kwargs.get("TEXT") if kwargs.get("TEXT") is not None else True,
        TITLE = kwargs.get("TITLE") if kwargs.get("TITLE") is not None else True,
        PRINT = kwargs.get("PRINT") if kwargs.get("PRINT") is not None else True,
        HEADERS = kwargs.get("HEADERS") if kwargs.get("HEADERS") is not None else True,
        STATUS_CODE = kwargs.get("STATUS_CODE") if kwargs.get("STATUS_CODE") is not None else True,
        TEXT_LENGTH = kwargs.get("TEXT_LENGTH") if kwargs.get("TEXT_LENGTH") is not None else True,
        CONTENT = kwargs.get("CONTENT")
        ))
    return responses

def requests_extracts(tasks, semaphore=2048) -> list():

    extracts_results=list()
    '''
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    loop = asyncio.get_event_loop()
    responses = loop.run_until_complete(requests_extracts_async_function_(tasks,semaphore))
    '''
    responses = requests_responses(tasks, semaphore)
    for response in responses:
        if response:
            Parser=ResponseParser()
            extracts_results.append( Parser.parse(response) )

    return extracts_results
